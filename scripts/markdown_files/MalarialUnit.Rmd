---
title: "SpatioTemporal"
author: "Jack Kissell"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
library('dplyr')
library('ggplot2')
library('fields')
library('sf')
library('RColorBrewer')
```

### Read in Data
I went with the "pf" data rather than the "pv" data; even though the pv data is more temporally variable, the case numbers are way lower (average of like 2-3 cases per year).
Also this is just a test of the methods on Nigeria but I downloaded a few countries

```{r}
#malaria csv
mal <- read.csv("WestAfrica.csv")

#areal unit boundaries
boundaries <- st_read("NG_Admin/nga_admbnda_adm1_osgof_20161215.shp")
boundaries <- boundaries[,c("admin0Name", "admin1Name", "geometry")]

#spelling corrections
boundaries[which(boundaries$admin1Name=="Nasarawa"),]$admin1Name <- "Nassarawa"
boundaries[which(boundaries$admin1Name=="Federal Capital Territory"),]$admin1Name <- "Abuja"

head(mal)
```

```{r}
#check boundaries
temp <- filter(mal, National.Unit == "Nigeria" & Metric == "Mortality Rate" & Year == 2022)

temp2 <- inner_join(boundaries, temp, c("admin1Name" = "Name"))

#Pal <- colorRampPalette(rev(RColorBrewer::brewer.pal(3, "YlGnBu")))
Pal <- colorRampPalette(brewer.pal(3, "YlOrRd"))
temp2$Col <- Pal(10)[as.numeric(cut(temp2$Value,breaks = 10))]

plot(st_geometry(temp2), col=temp2$Col)
```

```{r}
library(tmap)
temp3 <- filter(mal, National.Unit == "Nigeria" & Metric == "Mortality Rate")
temp3 <- inner_join(boundaries, temp3, c("admin1Name" = "Name"))

# map
#legend_title = expression("Cumulative Cases per 100,000 Population")
tm_shape(temp3) +
  tm_fill("Value", palette = magma(256), style ="cont", 
          legend.hist=FALSE, legend.is.portrait=FALSE, fig.dim = c(5, 8)) +
  tm_facets(by = "Year", ncol = 4) +
  tm_borders(col = "white", lwd = .05)  + # add borders +
  tm_layout(bg.color = "white", # change background colour
            legend.outside = TRUE, # legend outside
            legend.outside.position = "bottom",
            legend.stack = "horizontal",
            legend.title.size = 2,
            legend.width = 1,
            legend.height = 1,
            panel.label.size = 3) 
```



```{r}
t1 <- filter(temp3, National.Unit == "Nigeria" & Metric == "Mortality Rate" & Year == 2010)
t2 <- filter(temp3, National.Unit == "Nigeria" & Metric == "Mortality Rate" & Year == 2014)
t3 <- filter(temp3, National.Unit == "Nigeria" & Metric == "Mortality Rate" & Year == 2018)
t4 <- filter(temp3, National.Unit == "Nigeria" & Metric == "Mortality Rate" & Year == 2022)

par(mfrow=c(2,2), mar=c(2,2,2,2))
plot(st_geometry(t1), col=Pal(10)[as.numeric(cut(t1$Value,breaks = 10))], main="2010")
plot(st_geometry(t2), col=Pal(10)[as.numeric(cut(t2$Value,breaks = 10))], main="2014")
plot(st_geometry(t3), col=Pal(10)[as.numeric(cut(t3$Value,breaks = 10))], main="2018")
plot(st_geometry(t4), col=Pal(10)[as.numeric(cut(t4$Value,breaks = 10))], main="2022")
```



```{r}
hist(mal$Value)
```



```{r}
#temporal analysis
total_count <- mal %>% group_by(Year) %>%
  summarise(cases = sum(Value)) 

plot(total_count$Year, total_count$cases, type='l')
```

* start with univariate analysis (ie, analysis over the aggregate of time and space, so no spatial or temporal dimension). the idea is just to study the data big-picture
* then analyze the data from each dimension individually (ie spatial analysis and time-series analysis)
* initially model as a Poisson (can also use a negative Binomial)

* a possible model setup could look something like this (just a suggested framework, we can change these parameters):

$$
Y_{i,t} \sim Poisson(\mu_{i,t}) \\
\theta_{i,t} = \alpha + \beta x_i+ \nu_i + \omega_t \\
\nu_i \sim CAR(\sigma^2_v)

$$

here, $x_i$ is the spatial covariate, $\nu_i$ is the spatial random effect and $\omega_t$ is the temporal random effect.  
CAR model might not be appropriate in this specific context because Malaria is not contagious. Maybe model the spatial random effect using some other distribution.

```{r}
#relative risk
malPop$RR <- with(malPop, Observed / Expected)
malPop$logRR <- log(malPop$RR)
#average of RR is 1; interested in regions where RR is significantly > 1

# create proximity weights matrix W
W.nb <- poly2nb(malPop)                #build a neighbors list
W.list <- nb2listw(W.nb, style = "B")  #add spatial weights (basic binary coding)
W <- nb2mat(W.nb, style = "B")         #get weights matrix W
```

trying to fit Hierarchical S-T model with CAR spatial effect. Getting errors when running CARBayesST

```{r}
set.seed(999)

#model with no covariates
formula <- round(Observed) ~ offset(log(Expected)) + Pop

n.samples <- 5000
burn.in <- floor(0.25*n.samples)

model1 <- glm(formula = formula, family = "poisson", data = malPop)
coef(summary(model1))

model2 <- ST.CARar(formula, family = "poisson",
                   data = malPop, W = W, burnin = burn.in, 
                   n.sample = n.samples, AR=1, thin = 10)
```

Currently looking into issues with CARBayesST and trying to figure out how to fit a non-temporal Hierarchical model. Using the reference from the textbook chapter but having trouble translating code from WINBUG to R. I also saw that an alternative method involves fitting basis functions using the FRK package and then using a Poisson GLM with the basis functions as covariates so I will look into that as well. 

### Fit a FRK s-t model

Says in the documentation on Canvas that this method can only be used for point-reference data, but I've seen examples of it being used for Areal Units. Dr. Sang has also mentioned that you can fit basis functions to areal units in class so I can't see why this isn't applicable here.

```{r}
library(FRK)
library(sp)

mal.poly <- as(malPop, 'Spatial')   #convert data to SpatialPolygonDataFrame
#unsure if input to auto_basis is complete dataframe or just the spatial coordinates

#attempt 1 with full dataframe input to basis
basis <- auto_basis(
  data=mal.poly, nres=1, type="exp"
)


S <- eval_basis(basis, mal.poly)
S <- as.matrix(S)

colnames(S) <- paste0("B", 1:ncol(S)) #9 basis functions

#if needed: 
coords <- st_coordinates(st_centroid(boundaries))
lat <- coords[,1]
lon <- coords[,2]

#model here incorporates temporal aspect by using "Year" as a covariate
#incorporates spatial variability by including basis functions
func <- Observed ~ Year + average_precipitation + .

regdata <- as.data.frame(cbind(malPop, S))
regdata <- regdata[, c("Observed","Year","average_precipitation","B1","B2","B3","B4","B5","B6","B7","B8","B9")]

#getting non-integer warnings
regdata$Observed <- round(regdata$Observed, 0)

head(regdata)

#fit Poisson GLM
poisson_m1 <- glm(func,
                family = poisson("log"), # Poisson + log link
                data = regdata)
poisson_m1 %>% summary()
```

This model at least seemed to run. I still need to tweak the basis function setup since right now it is just generating evenly gridded radial basis functions, but I want it to generate basis functions for each areal unit.

```{r}
show_basis(basis)
```
